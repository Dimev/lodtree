//! Iterators over chunks

use crate::traits::*;
use crate::tree::*;

// helper to implement all iterators
macro_rules! impl_iterator {
    ($name:ident, $type:ty, $len:ident, $get:ident) => {
        // define the struct
        /// Iterator over chunks in the tree.
        /// This struct was automatically generated by a macro
        pub struct $name<'a, C: Sized, L: LodVec> {
            tree: &'a Tree<C, L>,
            index: usize,
        }

        // and implement iterator for it
        impl<'a, C: Sized, L: LodVec> Iterator for $name<'a, C, L> {
            type Item = $type;

            fn next(&mut self) -> Option<Self::Item> {
                // if the item is too big, stop
                if self.index >= self.tree.$len() {
                    None
                } else {
                    // otherwise, get the item
                    let item = self.tree.$get(self.index);

                    // increment the index
                    self.index += 1;

                    Some(item)
                }
            }
        }

		// exact size as well
		impl<'a, C: Sized, L: LodVec> ExactSizeIterator for $name<'a, C, L> {
			fn len(&self) -> usize {
				self.tree.$len()
			}
		}

		// fused, because it will always return none when done
		impl<'a, C: Sized, L: LodVec> std::iter::FusedIterator for $name<'a, C, L> {}
    };
}

macro_rules! impl_iterator_mut {
    ($name:ident, $type:ty, $len:ident, $get_mut:ident) => {
        // define the struct
        /// Iterator over chunks in the tree.
        /// This struct was automatically generated by a macro
        pub struct $name<'a, C: Sized, L: LodVec> {
            tree: &'a mut Tree<C, L>,
            index: usize,
        }

        // and implement iterator for it
        impl<'a, C: Sized, L: LodVec> Iterator for $name<'a, C, L> {
		// 3. ^^^ but, the lifetime must be valid for the lifetime `'a` as defined on the impl
            type Item = $type;

            fn next(&mut self) -> Option<Self::Item> {
            // 1. ^ first, the lifetime cannot outlive the anonymous lifetime defined on the method body
			// 4. ...so that the types are compatible
				// if the item is too big, stop
                if self.index >= self.tree.$len() {
                    None
                } else {
                    // otherwise, get the item
                    let item = self.tree.$get_mut(self.index);
					// 2. ^^ ...so that reference does not outlive borrowed content

                    // increment the index
                    self.index += 1;

                    Some(item)
                }
            }
        }

		// exact size as well
		impl<'a, C: Sized, L: LodVec> ExactSizeIterator for $name<'a, C, L> {
			fn len(&self) -> usize {
				self.tree.$len()
			}
		}

		// fused, because it will always return none when done
		impl<'a, C: Sized, L: LodVec> std::iter::FusedIterator for $name<'a, C, L> {}
    };
}

impl_iterator!(ChunkIter, &'a C, get_num_chunks, get_chunk);
impl_iterator!(PositionIter, L, get_num_chunks, get_chunk_position);
//impl_iterator_mut!(MutChunkIter, &'a mut C, get_num_chunks, get_chunk_mut);
impl_iterator!(
    ChunkToActivateIter,
    &'a C,
    get_num_chunks_to_activate,
    get_chunk_to_activate
);
impl_iterator!(
    PositionToActivateIter,
    L,
    get_num_chunks_to_activate,
    get_position_of_chunk_to_activate
);
impl_iterator!(
    ChunkToDeactivateIter,
    &'a C,
    get_num_chunks_to_deactivate,
    get_chunk_to_deactivate
);
impl_iterator!(
    PositionToDeactivateIter,
    L,
    get_num_chunks_to_deactivate,
    get_position_of_chunk_to_deactivate
);
impl_iterator!(
    ChunkToAddIter,
    &'a C,
    get_num_chunks_to_add,
    get_chunk_to_add
);
impl_iterator!(
    PositionToAddIter,
    L,
    get_num_chunks_to_add,
    get_position_of_chunk_to_add
);
impl_iterator!(
    ChunkToRemoveIter,
    &'a C,
    get_num_chunks_to_remove,
    get_chunk_to_remove
);
impl_iterator!(
    PositionToRemoveIter,
    L,
    get_num_chunks_to_remove,
    get_position_of_chunk_to_remove
);
impl_iterator!(
    ChunkToDeleteIter,
    &'a C,
    get_num_chunks_to_delete,
    get_chunk_to_delete
);
impl_iterator!(
    PositionToDeleteIter,
    L,
    get_num_chunks_to_delete,
    get_position_of_chunk_to_delete
);
// TODO: iterator for all

// iterator for all chunks that are inside given bounds
pub struct EditedChunksIter<L: LodVec> {
	// internal stack for which chunks are next
	stack: Vec<L>
}

impl<L: LodVec> Iterator for EditedChunksIter<L> {
	type Item = L;

	fn next(&mut self) -> Option<Self::Item> {

		if let Some(current) = self.stack.pop() {

			// go over all child nodes
			// if they are in bounds, and the correct depth, add them to the stack

			// and return this item from the stack
			Some(current)
		} else {
			None
		}
		
	}
}

impl<'a, C, L> Tree<C, L>
where
    C: Sized,
    L: LodVec,
    Self: 'a,
{
    /// iterate over all chunks
    #[inline]
    pub fn iter_chunks(&self) -> ChunkIter<C, L> {
        ChunkIter {
            tree: self,
            index: 0,
        }
    }

    // iterate over all chunks, mutable

	/// iterate over the position of all chunks
	#[inline]
    pub fn iter_position_of_chunks(&self) -> PositionIter<C, L> {
        PositionIter {
            tree: self,
            index: 0,
        }
    }

    /// iterate over all chunks to activate
    #[inline]
    pub fn iter_chunks_to_activate(&self) -> ChunkToActivateIter<C, L> {
        ChunkToActivateIter {
            tree: self,
            index: 0,
        }
    }

	/// iterate over all positions of the chunks to activate
    #[inline]
    pub fn iter_position_of_chunks_to_activate(&self) -> PositionToActivateIter<C, L> {
        PositionToActivateIter {
            tree: self,
            index: 0,
        }
    }

    // iterate over all chunks to activate, mut

    /// iterate over all chunks to deactivate
    #[inline]
    pub fn iter_chunks_to_deactivate(&self) -> ChunkToDeactivateIter<C, L> {
        ChunkToDeactivateIter {
            tree: self,
            index: 0,
        }
    }

	/// iterate over all positions of the chunks to deactivate
    #[inline]
    pub fn iter_position_of_chunks_to_deactivate(&self) -> PositionToDeactivateIter<C, L> {
        PositionToDeactivateIter {
            tree: self,
            index: 0,
        }
    }

    // iterate over all chunks to deactivate, mut

    /// iterate over all chunks to remove
    #[inline]
    pub fn iter_chunks_to_remove(&self) -> ChunkToRemoveIter<C, L> {
        ChunkToRemoveIter {
            tree: self,
            index: 0,
        }
    }

	/// iterate over all positions of the chunks to remove
    #[inline]
    pub fn iter_position_of_chunks_to_remove(&self) -> PositionToRemoveIter<C, L> {
        PositionToRemoveIter {
            tree: self,
            index: 0,
        }
    }

    // iterate over all chunks to remove, mut

    /// iterate over all chunks to add
    #[inline]
    pub fn iter_chunks_to_add(&self) -> ChunkToAddIter<C, L> {
        ChunkToAddIter {
            tree: self,
            index: 0,
        }
    }

    /// iterate over the positions of all chunks to add
    #[inline]
    pub fn iter_positions_of_chunks_to_add(&self) -> PositionToAddIter<C, L> {
        PositionToAddIter {
            tree: self,
            index: 0,
        }
    }

	/// iterate over all chunks to delete
    #[inline]
    pub fn iter_chunks_to_delete(&self) -> ChunkToDeleteIter<C, L> {
        ChunkToDeleteIter {
            tree: self,
            index: 0,
        }
    }

	/// iterate over all positions of the chunks to delete
    #[inline]
    pub fn iter_position_of_chunks_to_delete(&self) -> PositionToDeleteIter<C, L> {
        PositionToDeleteIter {
            tree: self,
            index: 0,
        }
    }

    // iterate over the positions and all mutable chunks to add

    // iterate over all chunks to add, mut

    // iterate over all chunks that would be affected by an edit

    // iterate over all chunks affected by an edit

    // iterate over all chunks that would be affected by an edit, including the chunk if it's in the tree
}
